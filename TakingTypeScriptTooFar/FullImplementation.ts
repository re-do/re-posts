// Available at https://www.typescriptlang.org/play?jsx=0#code/PTAEEkDsC5QQUqA9gIwFYFMDGAXUATDAMwEtIScSlIAoEUAeQFcdYAVACw1AGsMBPAM7IioHBwCGeQqXKVqoAO4ckg7gDcJAGyYZhAWylYOyJgCdGAB3mRtoDAA9LZvYKqIcGfZa1SMNHH5LbgZrd20AEWIAaQFBAB4GdHsHT0h8YVRMXAA+UABeUABvGlAy0HoAWQlLXjixSTxBFSYtfFAUbiQw6jscJAavNS11PQAaUAl05HEMM2F+0EgMUbMJxywdfDIAc0H9UCIzJAPZsSD-ctAAbVj+UDI6-iRRJLQAXVg324F3lLSMqAAAYAEiKghwZl2AF8APxA0Cw0B3UCwZarUrlegAUVSZgkuEmWi0oE0Oj0oAAFEhZhZxFMlis5gBKQ7HU5cUAuQStHATfgkDBtXZPYTKVQabS6YQSFxWGzaQQ0aHXPjPV7od40OhgTgkYT60BoJgQyZiKFYHhiAZEJBmLDcNgAZWt9gkOzmWnuKylflAHuWFsEExI3mO6hFgWCoA4ZBwSqj3GxZKYfnibDyhTY-ww6Uy6GwOExZSRJSu5Zu0QeiDVL1AbE+9duWor0OLqPr2vocGJSEUwmdrrIRDmgxSBLwiZEk0QWULoEsEkEanaiwkhyYkFw7gCF1AADlZcdFOnM8V27dq086w32M2c3mbn96PvqGpIGouRgAI5MEguVcBhqYIl24M4p2HOZcwdf0kAydsriRNhmwQ8o72iP5HABfNsiLCsSwPI8+3TZsclQsp0K1Ntd2jNgLgYIg3kLeJ2yiUQsNzQE51wMZ2ydRcHV4q5QgVLQ7mEDjH1rUQ2IKeVwi0NjxPiNiciE8oACUfz-ADxIfQFpNAWTClxTYmEIeJDLYiYRIU8SyLPWTJMBKZ+GuFtylLG4oEIBwrys4hGzo4IGJU4hrh8xx3gmfiCQwPI2yuWBk19TwWPw8oikrAQry039-wwfBxKC+iiDCogfn4aLQFih0EtAAAyc8MorSqr1s3oxLid5YXYUrysq6ravi8jykS8syJox1+usmqBO4QoimhRziH0nDC3bJDSqY3Bypi+ayKSozVuc4QIShSAdk2+tStxZxXHcPa5riw60NATceEgPtaCm0AADVtBIfA01m4a5KWlb2NSTj1twa6yxatrHgCohGwBrQgZB8K7iGg7UPGijjqh7DQHO3ZrvRzHPDu7k3GoJ7htewmgWxMxjjMWA2LICh3AME08E6UnIV2TILG4+MlBUT8tAwCRRhlOUycuwQADogW1Kc7kUO0MjYJBgopRb2yVnZYBN9tICYfROg5pYrZt9sUCQJAZamWAnZd2XaCuS3iTRVotHbVzYFc9t6AwHAsBV6PlQ1vcDYYrWdfiJOzHaU7r1EVPdf1i5BEzdts8EPWDcESrtbTrVfoTogaYe+n2zr5d3DWoWLp2dSymGmgzybunEAz0EikgiwOtsLQ4XVxCbpC2unFpx6x+0faXtAAAfd70mIMhCvbZL5-rgfocfIeR9ADSSB2DgcGhNewTPgAZYgb6nzyZ4wBi+8ei+r75Z66vXu-T+B9m70yfkQP+jM96gC-goQe99IAjgsOATw+gVTvFfgRGusDIDxBQV4FedV3LQJwa3QyRcS552ujXbO8QcFMw7KQjOhlu7TxrvEYa1wcG4xetAj6X1FA-SnJTYG1MQH9zoeIluGcTaEPinJERfgABi+Idj6FzDgdK5QcGdxgVI6guju6TWEYDURGAVHunUZATR7YLFqI0a3WR7YNLOzwDI4Wl1DHzR7nJOxVi3HH0BKfRBo4l4T3hBTUxyjVH+MSD0ceEwXE0jkQw2AfiHHwOHiEiwP9r63wQUg0A4CX6RIxmY9J1j4i5L-kkyBB1W61NGkiRRngKmaOKYk1xKTRqwBaeYmJGiqmX2vp05J-8RpHTaa3YJhT8FoPcpgxE-0omtIGZUuZoy6m8MmWsgJJNyECArjnUu11Gk7MsRkwJwgWHeOnmct6LM2Z2lgGCNp0IHjCC+ngdcZIgYpHuqAyAattRYDfHgRc8wFqgA4QdSkxt5q9JWRgeIh4nknkZt05kfVZ4wriikgoeQEZlG7L2fs-x8TbgUHWdcU4jgnBnJMMwKAKD4jMPcYwEhHh1mcN0JUVxQUfknBcNiAAFY4Dh+Ah0gPcQoyxFCgDFUgCVlIloTCyh6VgVJWT5DyImUV4r7jQmZO2FwOBzAeGFcQRVErY40AFaaRMwhCgQrUCq9sWA-A7DtJK5q+FbDqNgAAIhNoG3RVweQoA9Z4L1UI9BBqjRgGNbl3iBvbG2I1cdowAGFPXerkomOsjqVYJqTSCsFoAS3etgDm6NeajY+wkAG0AgaADizt8ChuNkwSNubY2CFgNcLK-qMBBoAEISA7RMCNggpj4EUCQYwcanygGhFRMtgrSbzTki6jAbqrgmjmLAIl5Zh1BpDWG8oRxBR5iDQesw7lO0ZR2McJglh+3NufUgV9D6026M-a+o9o11HWzmO+wNd6H0XrKJWtl8be38FhKmq40JdEwZ9cehtTbg0eJ2I+-CEaYOCjA2hn9yHlTGt+gAVTUBYQoBbRCCHmirO9NAgA

// In: An object definition
// Out: The keys of that definition whose values match our Optional expression template
type OptionalDefKeys<Obj extends object> = {
    // Map keys that should be optional to themselves, and others to never, excluding them from the type
    [Key in keyof Obj]: Obj[Key] extends `${string}?` ? Key : never
    // Extract all values (other than never) from the result, yielding keys whose values are Optionals
}[keyof Obj]

// This is just a trick to force TS to eagerly evaluate generics, improving type hints
type Evaluate<T> = T extends object
    ? {
          [K in keyof T]: T[K]
      }
    : T

// Allows TS to infer the exact type of an object passed to a function
type Narrow<T> = {
    [K in keyof T]: T[K] extends [] // Nonsense required to appease the type inference gods
        ? T[K]
        : T[K] extends object
        ? Narrow<T[K]>
        : T[K]
}

type TypeOfObject<
    Def extends object,
    Space,
    OptionalKeys extends keyof Def = OptionalDefKeys<Def>,
    RequiredKeys extends keyof Def = Exclude<keyof Def, OptionalKeys>
> = Def extends any[]
    ? { [Index in keyof Def]: TypeOf<Def[Index], Space> }
    : Evaluate<
          { [Key in RequiredKeys]: TypeOf<Def[Key], Space> } & {
              [Key in OptionalKeys]?: TypeOf<Def[Key], Space>
          }
      >

type TypeOf<Def, Space = {}> = Def extends object
    ? TypeOfObject<Def, Space>
    : Def extends string
    ? TypeOfExpression<Def, Space>
    : unknown

type Validate<Def, Space = {}> = Def extends object
    ? {
          [Key in keyof Def]: Validate<Def[Key], Space>
      }
    : Def extends string
    ? ValidateExpression<Def, Space>
    : `Error: Definitions must be strings or objects whose leaves are strings.`

type KeywordsToTypes = {
    string: string
    number: number
    boolean: boolean
    null: null
    any: any
    // etc...
}

type TypeOfKeyword<Keyword extends keyof KeywordsToTypes> =
    KeywordsToTypes[Keyword]

type TypeOfExpression<
    Expression extends string,
    Space
> = Expression extends `${infer Optional}?`
    ? TypeOfExpression<Optional, Space> | undefined
    : Expression extends `${infer Right}|${infer Left}`
    ? TypeOfExpression<Right, Space> | TypeOfExpression<Left, Space>
    : Expression extends `${infer Item}[]`
    ? TypeOfExpression<Item, Space>[]
    : Expression extends keyof KeywordsToTypes
    ? TypeOfKeyword<Expression>
    : Expression extends keyof Space
    ? TypeOf<Space[Expression], Space>
    : unknown

type ValidateExpression<Expression extends string, Space> = ValidateFragment<
    Expression,
    Expression,
    Space
>

type ValidateFragment<
    Fragment extends string,
    Root extends string,
    Space
> = Fragment extends `${infer Optional}?`
    ? ValidateFragment<Optional, Root, Space>
    : Fragment extends `${infer Right}|${infer Left}`
    ? ValidateFragment<Right, Root, Space> extends Root
        ? ValidateFragment<Left, Root, Space>
        : ValidateFragment<Right, Root, Space>
    : Fragment extends `${infer Item}[]`
    ? ValidateFragment<Item, Root, Space>
    : Fragment extends keyof KeywordsToTypes
    ? Root
    : Fragment extends keyof Space
    ? Root
    : `Error: ${Fragment} is not a valid expression.`

const parse = <Space>(
    space: Validate<Narrow<Space>, Space>
): TypeOf<Space, Space> => {
    // Allows extraction of a type from an arbitrary chain of props
    const typeDefProxy: any = new Proxy({}, { get: () => typeDefProxy })
    return typeDefProxy
}

const types = parse({
    category: {
        name: "string",
        subcategories: "category[]"
    }
})

type Category = typeof types.category

const category: Category = {
    name: "Good",
    // @ts-expect-error
    subcategories: [{ name: "Bad", subsandwiches: [] }]
}

const space = parse({
    user: {
        name: "string",
        friends: "user[]",
        groups: "group[]"
    },
    group: {
        members: "user[]",
        category: "category?"
    },
    category: {
        name: "string",
        subcategories: "category[]"
    }
})

type User = typeof space.user
